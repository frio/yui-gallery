<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/sm-selection/js/range.js - SmugMug YUI Gallery API docs</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="SmugMug YUI Gallery API docs"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 3.11.0-git</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Editor.html">Editor</a></li>
            
                <li><a href="../classes/Editor.Base.html">Editor.Base</a></li>
            
                <li><a href="../classes/Editor.Keys.html">Editor.Keys</a></li>
            
                <li><a href="../classes/Editor.Undo.html">Editor.Undo</a></li>
            
                <li><a href="../classes/Menu.html">Menu</a></li>
            
                <li><a href="../classes/Menu.Base.html">Menu.Base</a></li>
            
                <li><a href="../classes/Menu.Item.html">Menu.Item</a></li>
            
                <li><a href="../classes/Menu.Templates.html">Menu.Templates</a></li>
            
                <li><a href="../classes/Plugin.FocusManager.html">Plugin.FocusManager</a></li>
            
                <li><a href="../classes/Plugin.Menu.html">Plugin.Menu</a></li>
            
                <li><a href="../classes/Range.html">Range</a></li>
            
                <li><a href="../classes/Selection.html">Selection</a></li>
            
                <li><a href="../classes/TreeView.html">TreeView</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/dom-form-values.html">dom-form-values</a></li>
            
                <li><a href="../modules/gallery-sm-editor.html">gallery-sm-editor</a></li>
            
                <li><a href="../modules/gallery-sm-editor-base.html">gallery-sm-editor-base</a></li>
            
                <li><a href="../modules/gallery-sm-editor-keys.html">gallery-sm-editor-keys</a></li>
            
                <li><a href="../modules/gallery-sm-editor-undo.html">gallery-sm-editor-undo</a></li>
            
                <li><a href="../modules/gallery-sm-focusmanager.html">gallery-sm-focusmanager</a></li>
            
                <li><a href="../modules/gallery-sm-menu.html">gallery-sm-menu</a></li>
            
                <li><a href="../modules/gallery-sm-menu-base.html">gallery-sm-menu-base</a></li>
            
                <li><a href="../modules/gallery-sm-menu-item.html">gallery-sm-menu-item</a></li>
            
                <li><a href="../modules/gallery-sm-menu-plugin.html">gallery-sm-menu-plugin</a></li>
            
                <li><a href="../modules/gallery-sm-menu-templates.html">gallery-sm-menu-templates</a></li>
            
                <li><a href="../modules/gallery-sm-range.html">gallery-sm-range</a></li>
            
                <li><a href="../modules/gallery-sm-selection.html">gallery-sm-selection</a></li>
            
                <li><a href="../modules/gallery-sm-treeview.html">gallery-sm-treeview</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/sm-selection/js/range.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*jshint expr:true, onevar:false */

// Fun fact! The YUI Gallery currently doesn&#x27;t support conditional loading of
// modules based on feature detection like YUI core does, so that&#x27;s why all the
// legacy compat code is baked in here instead of in a separate conditionally
// loaded module.

/**
Provides the &#x60;Range&#x60; class, which normalizes Range behavior across browsers.

@module gallery-sm-selection
@submodule gallery-sm-range
**/

/**
Provides a friendly cross-browser Range API similar to the API defined in the
DOM Range specification.

@class Range
@param {window.Range} [range] Native Range object to wrap. If not provided, a
    new Range will be created.
@constructor
**/

var doc = Y.config.doc,
    win = Y.config.win,

    isHTML5 = !!(win &amp;&amp; win.Range &amp;&amp; doc.createRange);

var Range = isHTML5 ? function (range) {
    this._range = range || doc.createRange();
} : function (range) {
    this._range = range || doc.body.createTextRange();
};

Range.prototype = {
    // -- Public Methods -------------------------------------------------------

    /**
    Returns a new Range object with the same boundary points as this range.

    The returned Range is a copy, not a reference, so modifying it will not
    affect this range (and vice versa).

    @method clone
    @return {Range} New Range object with the same boundary points as this
        range.
    **/
    clone: isHTML5 ? function () {
        return new Y.Range(this._range.cloneRange());
    } : function () {
        throw new Error(&#x27;Not yet implemented.&#x27;);
    },

    /**
    Returns a Node instance containing a document fragment with a copy of this
    range&#x27;s contents.

    Event listeners are not copied.

    Element ids _are_ copied. This could lead to duplicate ids, so be careful.

    Partially selected nodes will include parent tags to ensure that the
    fragment is valid.

    @method cloneContents
    @return {Node} Node instance containing a document fragment with a copy of
        this range&#x27;s contents.
    **/
    cloneContents: isHTML5 ? function () {
        return Y.one(this._range.cloneContents());
    } : function () {
        throw new Error(&#x27;Not yet implemented.&#x27;);
    },

    /**
    Collapses this range by setting the start and end points to the same
    position, thus resulting in an empty range.

    @method collapse
    @param {Object} [options] Options.
        @param {Boolean} [options.toStart=false] If &#x60;true&#x60;, this range will be
            collapsed by moving the end point to the start point. Otherwise, the
            start point will be moved to the end point.
    @chainable
    **/
    collapse: function (options) {
        this._range.collapse(options &amp;&amp; options.toStart);
        return this;
    },

    /**
    Compares the start or end boundary of this range with the start or end
    boundary of another range.

    @method compare
    @param {Range} otherRange Range to compare to.
    @param {Object} [options] Options.

        @param {String} [options.myPoint=&#x27;start&#x27;] Specifies which boundary point
            on this range should be used for the comparison. Valid values are
            &#x27;start&#x27; to use this range&#x27;s start point for the comparison, or &#x27;end&#x27;
            to use this range&#x27;s end point.

        @param {String} [options.otherPoint=&#x27;start&#x27;] Specifies which boundary
            point on _otherRange_ should be used for the comparison. Valid
            values are &#x27;start&#x27; to use _otherRange_&#x27;s start point for the
            comparison, or &#x27;end&#x27; to use _otherRange_&#x27;s end point.

    @return {Number} -1, 0, or 1, indicating whether this range&#x27;s boundary is
        respectively before, equal to, or after the other range&#x27;s boundary.
    **/
    compare: isHTML5 ? function (otherRange, options) {
        // Make sure we&#x27;re working with a native range, not a YUI range.
        if (otherRange._range) {
            otherRange = otherRange._range;
        }

        var myPoint    = (options &amp;&amp; options.myPoint) || &#x27;start&#x27;,
            otherPoint = (options &amp;&amp; options.otherPoint) || &#x27;start&#x27;;

        var how = win.Range[otherPoint.toUpperCase() + &#x27;_TO_&#x27; +
                    myPoint.toUpperCase()];

        return this._range.compareBoundaryPoints(how, otherRange);
    } : function () {
        throw new Error(&#x27;Not yet implemented.&#x27;);
    },

    /**
    Removes the contents of this range from the DOM.

    @method deleteContents
    @chainable
    **/
    deleteContents: isHTML5 ? function () {
        this._range.deleteContents();
        return this;
    } : function () {
        throw new Error(&#x27;Not yet implemented.&#x27;);
    },

    /**
    Gets or sets the node that contains the end point of this range.

    When specifying an _offset_, you may specify either a number or the string
    &quot;before&quot; or &quot;after&quot;.

    A numerical offset will position the end point at that offset inside the
    _node_. If _node_ is a text node, the offset will represent a character
    position. If _node_ can contain child nodes, then the offset will represent
    a child index.

    The offset &quot;before&quot; will cause the end point to be placed immediately before
    _node_ (not inside it).

    The offset &quot;after&quot; will cause the end point to be placed immediately after
    _node_ (not inside it).

    @method endNode
    @param {HTMLElement|Node|String} [node] Node to set the end point to. May be
        specified as a Node instance, HTMLElement, or selector string. If not
        specified, the current end point will be returned.
    @param {Number|String} [offset=0] Offset position of the new end point
        relative to the _node_. If this is a number, it will be used as an
        offset position inside _node_. To specify a position immediately before
        _node_, use the string &quot;before&quot;. To specify a position immediately after
        _node_, use the string &quot;after&quot;.
    @return {Node} Node that contains the end point of this range.
    **/
    endNode: isHTML5 ? function (node, offset) {
        if (node) {
            var el = Y.one(node)._node;

            offset || (offset = 0);

            if (typeof offset === &#x27;number&#x27;) {
                this._range.setEnd(el, offset);
            } else if (offset === &#x27;before&#x27;) {
                this._range.setEndBefore(el);
            } else if (offset === &#x27;after&#x27;) {
                this._range.setEndAfter(el);
            }
        }

        return Y.one(this._range.endContainer);
    } : function (node, offset) {
        throw new Error(&#x27;Not yet implemented.&#x27;);
    },

    /**
    Gets or sets the offset of this selection&#x27;s end position inside the end
    node.

    If the end node is a text node, the offset represents a character position.
    If the end node can contain child nodes, then the offset represents a child
    index.

    When setting an offset, you may use a numerical offset (which behaves as
    described above) or the string &quot;before&quot; or &quot;after&quot;.

    The offset &quot;before&quot; will cause the end point to be placed immediately before
    the current end node (not inside it).

    The offset &quot;after&quot; will cause the end point to be placed immediately after
    the current end node (not inside it).

    Note that setting a &quot;before&quot; or &quot;after&quot; offset will change the end node. To
    get the new end node, call &#x60;endNode()&#x60;.

    @method endOffset
    @param {Number|String} [offset] Offset position of the new end point
        relative to the current end node. If this is a number, it will be used
        as an offset position inside the node. To specify a position immediately
        before the node, use the string &quot;before&quot;. To specify a position
        immediately after the node, use the string &quot;after&quot;.
    @return {Number} Offset of this selection&#x27;s end position inside the end
        node.
    **/
    endOffset: isHTML5 ? function (offset) {
        if (offset || offset === 0) {
            this.endNode(this._range.endContainer, offset);
        }

        return this._range.endOffset;
    } : function (offset) {
        throw new Error(&#x27;Not yet implemented.&#x27;);
    },

    /**
    Moves this range&#x27;s contents into a document fragment and returns a Node
    instance containing that fragment.

    Event listeners are not retained.

    If this range splits a non-text element, the resulting fragment will include
    a clone of that element, including its id (if it has one). This could lead
    to duplicate ids, so be careful.

    @method extractContents
    @return {Node} Node instance containing a document fragment with this
        range&#x27;s contents.
    **/
    extractContents: isHTML5 ? function () {
        return Y.one(this._range.extractContents());
    } : function () {
        throw new Error(&#x27;Not yet implemented.&#x27;);
    },

    /**
    Inserts a node at the start of this range.

    @method insertNode
    @param {HTMLElement|Node|String} node Node instance, HTMLElement, or
        selector string of a node to insert.
    @return {Node} Inserted node.
    **/
    insertNode: isHTML5 ? function (node) {
        node = Y.one(node);
        this._range.insertNode(node._node);
        return node;
    } : function () {
        throw new Error(&#x27;Not yet implemented.&#x27;);
    },

    /**
    Returns &#x60;true&#x60; if this range is collapsed, &#x60;false&#x60; otherwise.

    A &#x60;true&#x60; value means that the start and end points are the same and the
    range is empty, whereas a &#x60;false&#x60; value means that the start and end points
    are different and the range is not empty.

    @method isCollapsed
    @return {Boolean} &#x60;true&#x60; if this range is collapsed, &#x60;false&#x60; otherwise.
    **/
    isCollapsed: isHTML5 ? function () {
        return this._range.collapsed;
    } : function () {
        throw new Error(&#x27;Not yet implemented.&#x27;);
    },

    /**
    Returns &#x60;true&#x60; if this range has the same boundaries as _otherRange_,
    &#x60;false&#x60; otherwise.

    @method isEquivalent
    @param {Range} otherRange Range to compare this range to.
    @return {Boolean} &#x60;true&#x60; if this range has the same boundaries as
        _otherRange_, &#x60;false&#x60; otherwise.
    **/
    isEquivalent: function (otherRange) {
        return otherRange &amp;&amp; this.compare(otherRange) === 0 &amp;&amp;
                this.compare(otherRange, {myPoint: &#x27;end&#x27;, otherPoint: &#x27;end&#x27;}) === 0;
    },

    /**
    Returns &#x60;true&#x60; if this range is entirely contained within the given _node_.

    @method isInsideNode
    @param {HTMLElement|Node|String} node Node instance, HTML element, or
        selector string of the container.
    @return {Boolean} &#x60;true&#x60; if this range is entirely contained within the
        given _node_, &#x60;false&#x60; otherwise.
    **/
    isInsideNode: function (node) {
        var el       = Y.one(node)._node,
            parentEl = this.parentNode()._node;

        if (el === parentEl) {
            return true;
        }

        while (parentEl = parentEl.parentNode) {
            if (el === parentEl) {
                return true;
            }
        }

        return false;
    },

    /**
    Returns the nearest common ancestor node that fully contains all nodes
    within this range.

    @method parentNode
    @return {Node} Nearest common ancestor node that fully contains all nodes
        within this range.
    **/
    parentNode: isHTML5 ? function () {
        return Y.one(this._range.commonAncestorContainer);
    } : function () {
        return Y.one(this._range.parentElement());
    },

    /**
    Gets or sets the node that contains the start point of this range.

    When specifying an _offset_, you may specify either a number or the string
    &quot;before&quot; or &quot;after&quot;.

    A numerical offset will position the start point at that offset inside the
    _node_. If _node_ is a text node, the offset will represent a character
    position. If _node_ can contain child nodes, then the offset will represent
    a child index.

    The offset &quot;before&quot; will cause the start point to be placed immediately
    before _node_ (not inside it).

    The offset &quot;after&quot; will cause the start point to be placed immediately after
    _node_ (not inside it).

    @method startNode
    @param {HTMLElement|Node|String} [node] Node to set the start point to. May
        be specified as a Node instance, HTMLElement, or selector string. If not
        specified, the current start point will be returned.
    @param {Number|String} [offset=0] Offset position of the new start point
        relative to the _node_. If this is a number, it will be used as an
        offset position inside _node_. To specify a position immediately before
        _node_, use the string &quot;before&quot;. To specify a position immediately after
        _node_, use the string &quot;after&quot;.
    @return {Node} Node that contains the start point of this range.
    **/
    startNode: isHTML5 ? function (node, offset) {
        if (node) {
            var el = Y.one(node)._node;

            offset || (offset = 0);

            if (typeof offset === &#x27;number&#x27;) {
                this._range.setStart(el, offset);
            } else if (offset === &#x27;before&#x27;) {
                this._range.setStartBefore(el);
            } else if (offset === &#x27;after&#x27;) {
                this._range.setStartAfter(el);
            }
        }

        return Y.one(this._range.startContainer);
    } : function (node, offset) {
        throw new Error(&#x27;Not yet implemented.&#x27;);
    },

    /**
    Gets or sets the offset of this range&#x27;s start position inside the start
    node.

    If the start node is a text node, the offset represents a character
    position. If the start node can contain child nodes, then the offset
    represents a child index.

    When setting an offset, you may use a numerical offset (which behaves as
    described above) or the string &quot;before&quot; or &quot;after&quot;.

    The offset &quot;before&quot; will cause the start point to be placed immediately
    before the current start node (not inside it).

    The offset &quot;after&quot; will cause the start point to be placed immediately after
    the current start node (not inside it).

    Note that setting a &quot;before&quot; or &quot;after&quot; offset will change the start node.
    To get the new start node, call &#x60;startNode()&#x60;.

    @method startOffset
    @param {Number|String} [offset] Offset position of the new start point
        relative to the current start node. If this is a number, it will be used
        as an offset position inside the node. To specify a position immediately
        before the node, use the string &quot;before&quot;. To specify a position
        immediately after the node, use the string &quot;after&quot;.
    @return {Number} Offset of this range&#x27;s start position inside the start
        node.
    **/
    startOffset: isHTML5 ? function (offset) {
        if (offset || offset === 0) {
            this.startNode(this._range.startContainer, offset);
        }

        return this._range.startOffset;
    } : function (offset) {
        throw new Error(&#x27;Not yet implemented.&#x27;);
    },

    /**
    Returns the HTML content of this range.

    @method toHTML
    @return {HTML} HTML content of this range.
    **/
    toHTML: isHTML5 ? function () {
        var div = doc.createElement(&#x27;div&#x27;);
        div.appendChild(this._range.cloneContents());

        return div.innerHTML;
    } : function () {
        return this._range.htmlText;
    },

    /**
    Returns the plain text content of this range.

    @method toString
    @return {String} Plain text content of this range.
    **/
    toString: isHTML5 ? function () {
        return this._range.toString();
    } : function () {
        return this._range.text;
    },

    /**
    Traverses the contents of the range, passing each node and its children to
    the supplied callback in document order.

    For example, if the range includes the following HTML...

        lorem ipsum &lt;b&gt;dolor &lt;i&gt;sit&lt;/i&gt;&lt;/b&gt; amet

    ...then this &#x60;traverse()&#x60; call...

        range.traverse(function (node) {
            console.log(Y.Node.getDOMNode(node));
        });

    ...would result in the following console output:

        &quot;lorem ipsum &quot;
        &lt;b&gt; element
        &quot;dolor &quot;
        &lt;i&gt; element
        &quot;sit&quot;
        &quot; amet&quot;

    The entire start and end node will be included even if the range only
    includes a portion of them. Use the &#x60;startOffset()&#x60; and &#x60;endOffset()&#x60;
    methods to determine where the precise boundaries are if necessary.

    @method traverse
    @param {Function} callback Callback function.
        @param {Node} callback.node Node instance.
    @param {Object} [thisObj] &#x60;this&#x60; object to use when calling the callback
        function.
    @chainable
    **/
    traverse: function (callback, thisObj) {
        if (this.isCollapsed()) {
            return this;
        }

        var container = this.parentNode()._node,
            end       = this.endNode()._node,
            endOffset = this.endOffset();

        // If there&#x27;s a positive offset and the end node has children, we need
        // to take the offset into account when traversing. Otherwise we can
        // ignore it.
        if (endOffset &amp;&amp; end.childNodes.length) {
            end = end.childNodes[endOffset];
        }

        function traverseDOMNode(domNode) {
            callback.call(thisObj, Y.one(domNode));

            if (domNode === end) {
                return;
            }

            if (domNode.firstChild) {
                traverseDOMNode(domNode.firstChild);
            } else if (domNode.nextSibling) {
                traverseDOMNode(domNode.nextSibling);
            } else {
                var node = domNode;

                while (node = node.parentNode) {
                    if (node !== container &amp;&amp; node.nextSibling) {
                        traverseDOMNode(node.nextSibling);
                        break;
                    }
                }
            }
        }

        traverseDOMNode(this.startNode()._node);

        return this;
    },

    /**
    Wraps this range in the specified HTML and returns the new wrapper node.

    @method wrap
    @param {HTML} html HTML string.
    @param {Object} [options] Options.
        @param {Boolean} [options.includeWrapper=false] If &#x60;true&#x60;, this range
            will be updated to include the new wrapper node.
    @return {Node} New wrapper node.
    **/
    wrap: isHTML5 ? function (html, options) {
        // We have to manually extract the range&#x27;s contents and append them to
        // the wrapper instead of just using Range#surroundContents(), because
        // surroundContents() will throw an exception if one of the Range&#x27;s
        // boundary points splits a non-text node.
        //
        // It&#x27;s puzzling that this is part of the Range spec, because the error
        // doesn&#x27;t do anyone any good, and extractContents() (which is used
        // internally by surroundContents()) already requires the browser to
        // implement node splitting anyway. But whatevs.
        var contents  = this._range.extractContents(),
            container = Y.DOM.create(html); // TODO: handle fragments?

        container.appendChild(contents);
        this._range.insertNode(container);

        if (options &amp;&amp; options.includeWrapper) {
            this._range.selectNode(container);
        } else {
            this._range.selectNodeContents(container);
        }

        return Y.one(container);
    } : function (html) {
        throw new Error(&#x27;Not yet implemented.&#x27;);
    }
};

Y.Range = Range;

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
